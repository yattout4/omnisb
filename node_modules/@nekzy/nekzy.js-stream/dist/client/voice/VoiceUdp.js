"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VoiceUdp = void 0;
const dgram_1 = __importDefault(require("dgram"));
const net_1 = require("net");
const AudioPacketizer_1 = require("../packet/AudioPacketizer");
const BaseMediaPacketizer_1 = require("../packet/BaseMediaPacketizer");
const VideoPacketizer_1 = require("../packet/VideoPacketizer");
// credit to discord.js
function parseLocalPacket(message) {
    const packet = Buffer.from(message);
    const ip = packet.subarray(8, packet.indexOf(0, 8)).toString('utf8');
    if (!(0, net_1.isIPv4)(ip)) {
        throw new Error('Malformed IP address');
    }
    const port = packet.readUInt16BE(packet.length - 2);
    return { ip, port };
}
class VoiceUdp {
    constructor(voiceConnection) {
        this.nonce = 0;
        this._voiceConnection = voiceConnection;
        this._audioPacketizer = new AudioPacketizer_1.AudioPacketizer(this);
        this._videoPacketizer = new VideoPacketizer_1.VideoPacketizer(this);
    }
    getNewNonceBuffer() {
        const nonceBuffer = Buffer.alloc(24);
        this.nonce++;
        if (this.nonce > BaseMediaPacketizer_1.max_int32bit)
            this.nonce = 0;
        nonceBuffer.writeUInt32BE(this.nonce, 0);
        return nonceBuffer;
    }
    get audioPacketizer() {
        return this._audioPacketizer;
    }
    get videoPacketizer() {
        return this._videoPacketizer;
    }
    get voiceConnection() {
        return this._voiceConnection;
    }
    sendAudioFrame(frame) {
        if (!this.ready)
            return;
        const packet = this.audioPacketizer.createPacket(frame);
        this.sendPacket(packet);
        this.audioPacketizer.onFrameSent();
    }
    /**
     * Sends packets after partitioning the video frame into
     * MTU-sized chunks
     * @param frame
     */
    sendVideoFrame(frame) {
        if (!this.ready)
            return;
        const data = this.videoPacketizer.partitionVideoData(frame);
        for (let i = 0; i < data.length; i++) {
            const packet = this.videoPacketizer.createPacket(data[i], i === (data.length - 1), i === 0);
            this.sendPacket(packet);
        }
        this.videoPacketizer.onFrameSent();
    }
    sendPacket(packet) {
        return new Promise((resolve, reject) => {
            try {
                this.socket.send(packet, 0, packet.length, this._voiceConnection.port, this._voiceConnection.address, (error, bytes) => {
                    if (error) {
                        console.log("ERROR", error);
                        reject(error);
                    }
                    resolve();
                });
            }
            catch (e) {
                reject(e);
            }
        });
    }
    handleIncoming(buf) {
        //console.log("RECEIVED PACKET", buf);
    }
    get ready() {
        return this._ready;
    }
    set ready(val) {
        this._ready = val;
    }
    stop() {
        try {
            this.ready = false;
            this.socket.disconnect();
        }
        catch (e) { }
    }
    createUdp() {
        return new Promise((resolve, reject) => {
            this.socket = dgram_1.default.createSocket('udp4');
            this.socket.on('error', (error) => {
                console.error("Error connecting to media udp server", error);
                reject(error);
            });
            this.socket.once('message', (message) => {
                if (message.readUInt16BE(0) !== 2) {
                    reject('wrong handshake packet for udp');
                }
                try {
                    const packet = parseLocalPacket(message);
                    this._voiceConnection.self_ip = packet.ip;
                    this._voiceConnection.self_port = packet.port;
                    this._voiceConnection.setProtocols();
                }
                catch (e) {
                    reject(e);
                }
                resolve();
                this.socket.on('message', this.handleIncoming);
            });
            const blank = Buffer.alloc(74);
            blank.writeUInt16BE(1, 0);
            blank.writeUInt16BE(70, 2);
            blank.writeUInt32BE(this._voiceConnection.ssrc, 4);
            this.socket.send(blank, 0, blank.length, this._voiceConnection.port, this._voiceConnection.address, (error, bytes) => {
                if (error) {
                    reject(error);
                }
            });
        });
    }
}
exports.VoiceUdp = VoiceUdp;
